/* Generated by wayland-scanner 1.16.0 */

#ifndef IASSHELL_CLIENT_PROTOCOL_H
#define IASSHELL_CLIENT_PROTOCOL_H

#include <stdint.h>
#include <stddef.h>
#include "wayland-client.h"

#ifdef  __cplusplus
extern "C" {
#endif

/**
 * @page page_iasshell The iasshell protocol
 * @section page_ifaces_iasshell Interfaces
 * - @subpage page_iface_ias_shell - IVI shell interface
 * - @subpage page_iface_ias_surface - IAS shell surface interface
 * - @subpage page_iface_ias_hmi - IVI HMI interface
 * - @subpage page_iface_ias_relay_input - IAS relay user input interface
 * @section page_copyright_iasshell Copyright
 * <pre>
 *
 * Copyright (c) 2012, Intel Corporation.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * </pre>
 */
struct ias_hmi;
struct ias_relay_input;
struct ias_shell;
struct ias_surface;
struct wl_output;
struct wl_surface;

/**
 * @page page_iface_ias_shell ias_shell
 * @section page_iface_ias_shell_desc Description
 *
 * This interface provides the IVI-specific shell functionality
 * exposed by the Intel Automotive Solutions shell.
 * @section page_iface_ias_shell_api API
 * See @ref iface_ias_shell.
 */
/**
 * @defgroup iface_ias_shell The ias_shell interface
 *
 * This interface provides the IVI-specific shell functionality
 * exposed by the Intel Automotive Solutions shell.
 */
extern const struct wl_interface ias_shell_interface;
/**
 * @page page_iface_ias_surface ias_surface
 * @section page_iface_ias_surface_desc Description
 *
 * An interface implemented by a wl_surface.  On server side the
 * object is automatically destroyed when the related wl_surface is
 * destroyed.  On client side, ias_surface_destroy() must be
 * called before destroying the wl_surface object.
 * @section page_iface_ias_surface_api API
 * See @ref iface_ias_surface.
 */
/**
 * @defgroup iface_ias_surface The ias_surface interface
 *
 * An interface implemented by a wl_surface.  On server side the
 * object is automatically destroyed when the related wl_surface is
 * destroyed.  On client side, ias_surface_destroy() must be
 * called before destroying the wl_surface object.
 */
extern const struct wl_interface ias_surface_interface;
/**
 * @page page_iface_ias_hmi ias_hmi
 * @section page_iface_ias_hmi_desc Description
 *
 * This interface provides a client application to control other
 * application's surfaces.
 * @section page_iface_ias_hmi_api API
 * See @ref iface_ias_hmi.
 */
/**
 * @defgroup iface_ias_hmi The ias_hmi interface
 *
 * This interface provides a client application to control other
 * application's surfaces.
 */
extern const struct wl_interface ias_hmi_interface;
/**
 * @page page_iface_ias_relay_input ias_relay_input
 * @section page_iface_ias_relay_input_desc Description
 *
 * This interface allows a client application to send events to other
 * applications via the server.
 * @section page_iface_ias_relay_input_api API
 * See @ref iface_ias_relay_input.
 */
/**
 * @defgroup iface_ias_relay_input The ias_relay_input interface
 *
 * This interface allows a client application to send events to other
 * applications via the server.
 */
extern const struct wl_interface ias_relay_input_interface;

/**
 * @ingroup iface_ias_shell
 * @struct ias_shell_listener
 */
struct ias_shell_listener {
	/**
	 * Surface resize
	 *
	 * This provides a standard surface resize notification, exactly
	 * the same as what desktop_shell provides, except there is no
	 * notion of edges since IVI doesn't have a mouse interface for
	 * resizing windows like desktop does.
	 */
	void (*configure)(void *data,
			  struct ias_shell *ias_shell,
			  struct ias_surface *surface,
			  int32_t width,
			  int32_t height);
};

/**
 * @ingroup iface_ias_shell
 */
static inline int
ias_shell_add_listener(struct ias_shell *ias_shell,
		       const struct ias_shell_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) ias_shell,
				     (void (**)(void)) listener, data);
}

#define IAS_SHELL_SET_BACKGROUND 0
#define IAS_SHELL_SET_PARENT 1
#define IAS_SHELL_SET_PARENT_WITH_POSITION 2
#define IAS_SHELL_POPUP 3
#define IAS_SHELL_SET_ZORDER 4
#define IAS_SHELL_SET_BEHAVIOR 5
#define IAS_SHELL_GET_IAS_SURFACE 6

/**
 * @ingroup iface_ias_shell
 */
#define IAS_SHELL_CONFIGURE_SINCE_VERSION 1

/**
 * @ingroup iface_ias_shell
 */
#define IAS_SHELL_SET_BACKGROUND_SINCE_VERSION 1
/**
 * @ingroup iface_ias_shell
 */
#define IAS_SHELL_SET_PARENT_SINCE_VERSION 1
/**
 * @ingroup iface_ias_shell
 */
#define IAS_SHELL_SET_PARENT_WITH_POSITION_SINCE_VERSION 1
/**
 * @ingroup iface_ias_shell
 */
#define IAS_SHELL_POPUP_SINCE_VERSION 1
/**
 * @ingroup iface_ias_shell
 */
#define IAS_SHELL_SET_ZORDER_SINCE_VERSION 1
/**
 * @ingroup iface_ias_shell
 */
#define IAS_SHELL_SET_BEHAVIOR_SINCE_VERSION 1
/**
 * @ingroup iface_ias_shell
 */
#define IAS_SHELL_GET_IAS_SURFACE_SINCE_VERSION 1

/** @ingroup iface_ias_shell */
static inline void
ias_shell_set_user_data(struct ias_shell *ias_shell, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) ias_shell, user_data);
}

/** @ingroup iface_ias_shell */
static inline void *
ias_shell_get_user_data(struct ias_shell *ias_shell)
{
	return wl_proxy_get_user_data((struct wl_proxy *) ias_shell);
}

static inline uint32_t
ias_shell_get_version(struct ias_shell *ias_shell)
{
	return wl_proxy_get_version((struct wl_proxy *) ias_shell);
}

/** @ingroup iface_ias_shell */
static inline void
ias_shell_destroy(struct ias_shell *ias_shell)
{
	wl_proxy_destroy((struct wl_proxy *) ias_shell);
}

/**
 * @ingroup iface_ias_shell
 *
 * Sets the desktop background for an output to a specific
 * surface.  This is typically used to create a "wallpaper"
 * although it can also be used to create a "live" background as
 * well.  
 */
static inline void
ias_shell_set_background(struct ias_shell *ias_shell, struct wl_output *output, struct ias_surface *surface)
{
	wl_proxy_marshal((struct wl_proxy *) ias_shell,
			 IAS_SHELL_SET_BACKGROUND, output, surface);
}

/**
 * @ingroup iface_ias_shell
 *
 * Marks a surface as a child of the specified parent surface.
 * Child surfaces will move together with their parent surface in
 * the default layout.  Handling of child surfaces in other
 * display layouts is left to the layout plugin to decide (e.g.,
 * it may not make sense to even draw child surfaces in some
 * kinds of display layouts).
 */
static inline void
ias_shell_set_parent(struct ias_shell *ias_shell, struct ias_surface *surface, struct ias_surface *parent)
{
	wl_proxy_marshal((struct wl_proxy *) ias_shell,
			 IAS_SHELL_SET_PARENT, surface, parent);
}

/**
 * @ingroup iface_ias_shell
 *
 * Marks a surface as a child of the specified parent surface, in
 * addition to providing relative x and y offsets for the child
 * surface.
 * Child surfaces will move together with their parent surface in
 * the default layout.  Handling of child surfaces in other
 * display layouts is left to the layout plugin to decide (e.g.,
 * it may not make sense to even draw child surfaces in some
 * kinds of display layouts).
 */
static inline void
ias_shell_set_parent_with_position(struct ias_shell *ias_shell, struct ias_surface *surface, struct ias_surface *parent, int32_t x, int32_t y)
{
	wl_proxy_marshal((struct wl_proxy *) ias_shell,
			 IAS_SHELL_SET_PARENT_WITH_POSITION, surface, parent, x, y);
}

/**
 * @ingroup iface_ias_shell
 *
 * Requests that a popup be presented with the specified priority.
 * Popups are important surfaces that are presented to the user
 * regardless of what application is currently running.  Popups
 * are assigned priority levels to prevent less important popups
 * from obscuring more important popups and to allow more
 * important popups to override less important ones.  Priorities
 * are expressed via integer values with lower values being more
 * important and taking precedence.
 *
 * TODO:  May need to add an authentication framework to allow only
 * privileged apps to use the lowest priority values.
 */
static inline void
ias_shell_popup(struct ias_shell *ias_shell, struct wl_output *output, struct ias_surface *surface, uint32_t priority)
{
	wl_proxy_marshal((struct wl_proxy *) ias_shell,
			 IAS_SHELL_POPUP, output, surface, priority);
}

/**
 * @ingroup iface_ias_shell
 *
 * Assigns a surface to a specific zorder.  Zorder is a way of
 * organizing surfaces to enforce z-order restrictions.  The IAS
 * shell uses some zorder values internally for shell-specific
 * functionality (background surface, fullscreen surface, popups,
 * etc.), but applications are free to create their own zorders to
 * organize other types of applications to their liking.
 */
static inline void
ias_shell_set_zorder(struct ias_shell *ias_shell, struct ias_surface *surface, uint32_t zorder)
{
	wl_proxy_marshal((struct wl_proxy *) ias_shell,
			 IAS_SHELL_SET_ZORDER, surface, zorder);
}

/**
 * @ingroup iface_ias_shell
 *
 * Sets the behavior bits for a surface.  Behavior bits control
 * how the surface is drawn, animated, transitioned, etc. in
 * various display layouts.  Only the lower 24 bits of the value
 * passed to this request will be honored; the upper 8 bits are
 * reserved for internal use by the IAS shell itself.
 */
static inline void
ias_shell_set_behavior(struct ias_shell *ias_shell, struct ias_surface *surface, uint32_t behavior)
{
	wl_proxy_marshal((struct wl_proxy *) ias_shell,
			 IAS_SHELL_SET_BEHAVIOR, surface, behavior);
}

/**
 * @ingroup iface_ias_shell
 *
 * Create a new ias shell surface for an existing wl_surface.
 */
static inline struct ias_surface *
ias_shell_get_ias_surface(struct ias_shell *ias_shell, struct wl_surface *surface, const char *name)
{
	struct wl_proxy *id;

	id = wl_proxy_marshal_constructor((struct wl_proxy *) ias_shell,
			 IAS_SHELL_GET_IAS_SURFACE, &ias_surface_interface, NULL, surface, name);

	return (struct ias_surface *) id;
}

/**
 * @ingroup iface_ias_surface
 * @struct ias_surface_listener
 */
struct ias_surface_listener {
	/**
	 * ping client
	 *
	 * Ping a client to check if it is receiving events and sending
	 * requests. A client is expected to reply with a pong request.
	 */
	void (*ping)(void *data,
		     struct ias_surface *ias_surface,
		     uint32_t serial);
	/**
	 * suggest resize
	 *
	 * The configure event asks the client to resize its surface. The
	 * size is a hint, in the sense that the client is free to ignore
	 * it if it doesn't resize, pick a smaller size (to satisfy aspect
	 * ratio or resize in steps of NxM pixels). The client is free to
	 * dismiss all but the last configure event it received.
	 */
	void (*configure)(void *data,
			  struct ias_surface *ias_surface,
			  int32_t width,
			  int32_t height);
};

/**
 * @ingroup iface_ias_surface
 */
static inline int
ias_surface_add_listener(struct ias_surface *ias_surface,
			 const struct ias_surface_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) ias_surface,
				     (void (**)(void)) listener, data);
}

#define IAS_SURFACE_PONG 0
#define IAS_SURFACE_SET_TITLE 1
#define IAS_SURFACE_SET_FULLSCREEN 2
#define IAS_SURFACE_UNSET_FULLSCREEN 3

/**
 * @ingroup iface_ias_surface
 */
#define IAS_SURFACE_PING_SINCE_VERSION 1
/**
 * @ingroup iface_ias_surface
 */
#define IAS_SURFACE_CONFIGURE_SINCE_VERSION 1

/**
 * @ingroup iface_ias_surface
 */
#define IAS_SURFACE_PONG_SINCE_VERSION 1
/**
 * @ingroup iface_ias_surface
 */
#define IAS_SURFACE_SET_TITLE_SINCE_VERSION 1
/**
 * @ingroup iface_ias_surface
 */
#define IAS_SURFACE_SET_FULLSCREEN_SINCE_VERSION 1
/**
 * @ingroup iface_ias_surface
 */
#define IAS_SURFACE_UNSET_FULLSCREEN_SINCE_VERSION 1

/** @ingroup iface_ias_surface */
static inline void
ias_surface_set_user_data(struct ias_surface *ias_surface, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) ias_surface, user_data);
}

/** @ingroup iface_ias_surface */
static inline void *
ias_surface_get_user_data(struct ias_surface *ias_surface)
{
	return wl_proxy_get_user_data((struct wl_proxy *) ias_surface);
}

static inline uint32_t
ias_surface_get_version(struct ias_surface *ias_surface)
{
	return wl_proxy_get_version((struct wl_proxy *) ias_surface);
}

/** @ingroup iface_ias_surface */
static inline void
ias_surface_destroy(struct ias_surface *ias_surface)
{
	wl_proxy_destroy((struct wl_proxy *) ias_surface);
}

/**
 * @ingroup iface_ias_surface
 *
 * A client must respond to a ping event with a pong request or
 * the client may be deemed unresponsive.
 */
static inline void
ias_surface_pong(struct ias_surface *ias_surface, uint32_t serial)
{
	wl_proxy_marshal((struct wl_proxy *) ias_surface,
			 IAS_SURFACE_PONG, serial);
}

/**
 * @ingroup iface_ias_surface
 *
 * This changes the surface's title, from what it was originally set to
 * when we grabbed the ias surface.
 */
static inline void
ias_surface_set_title(struct ias_surface *ias_surface, const char *title)
{
	wl_proxy_marshal((struct wl_proxy *) ias_surface,
			 IAS_SURFACE_SET_TITLE, title);
}

/**
 * @ingroup iface_ias_surface
 *
 * This maps the surface as a fullscreen surface. A NULL output argument
 * is acceptable and it signifies that the client wants to use the 
 * default output.
 */
static inline void
ias_surface_set_fullscreen(struct ias_surface *ias_surface, struct wl_output *output)
{
	wl_proxy_marshal((struct wl_proxy *) ias_surface,
			 IAS_SURFACE_SET_FULLSCREEN, output);
}

/**
 * @ingroup iface_ias_surface
 *
 * This maps the surface to being inside a window (not fullscreen).
 * Client provides the new width and height for its surface. 
 */
static inline void
ias_surface_unset_fullscreen(struct ias_surface *ias_surface, uint32_t width, uint32_t height)
{
	wl_proxy_marshal((struct wl_proxy *) ias_surface,
			 IAS_SURFACE_UNSET_FULLSCREEN, width, height);
}

#ifndef IAS_HMI_VISIBLE_OPTIONS_ENUM
#define IAS_HMI_VISIBLE_OPTIONS_ENUM
enum ias_hmi_visible_options {
	/**
	 * Hide the surface
	 */
	IAS_HMI_VISIBLE_OPTIONS_HIDDEN = 0,
	/**
	 * Show the surface
	 */
	IAS_HMI_VISIBLE_OPTIONS_VISIBLE = 1,
};
#endif /* IAS_HMI_VISIBLE_OPTIONS_ENUM */

#ifndef IAS_HMI_FCAP_ERROR_ENUM
#define IAS_HMI_FCAP_ERROR_ENUM
enum ias_hmi_FCAP_ERROR {
	/**
	 * No error
	 */
	IAS_HMI_FCAP_ERROR_OK = 0,
	/**
	 * No capture proxy available
	 */
	IAS_HMI_FCAP_ERROR_NO_CAPTURE_PROXY = 1,
	/**
	 * Duplicate surface or output requested
	 */
	IAS_HMI_FCAP_ERROR_DUPLICATE = 2,
	/**
	 * Capture proxy not built in
	 */
	IAS_HMI_FCAP_ERROR_NOT_BUILT_IN = 3,
	/**
	 * Invalid argument
	 */
	IAS_HMI_FCAP_ERROR_INVALID = 4,
};
#endif /* IAS_HMI_FCAP_ERROR_ENUM */

/**
 * @ingroup iface_ias_hmi
 * @struct ias_hmi_listener
 */
struct ias_hmi_listener {
	/**
	 * Notifies listeners of surface changes
	 *
	 * Notifies clients listening on the ias_hmi interface that a
	 * surface has been created or modified.
	 */
	void (*surface_info)(void *data,
			     struct ias_hmi *ias_hmi,
			     uint32_t id,
			     const char *title,
			     uint32_t z_order,
			     int32_t x,
			     int32_t y,
			     uint32_t width,
			     uint32_t height,
			     uint32_t alpha,
			     uint32_t behavior,
			     uint32_t pid,
			     const char *pname,
			     uint32_t output,
			     uint32_t flipped);
	/**
	 * Notifies listeners of surface destruction
	 *
	 * Notifies clients listening on the ias_hmi interface that an
	 * existing surface has been destroyed, allowing them to clean up
	 * their internal bookkeeping.
	 */
	void (*surface_destroyed)(void *data,
				  struct ias_hmi *ias_hmi,
				  uint32_t id,
				  const char *title,
				  uint32_t pid,
				  const char *pname);
	/**
	 * Notifies listeners of surface sharing changes
	 *
	 * Notifies clients listening on the ias_hmi interface that a
	 * surface sharing has been enabled or disabled.
	 */
	void (*surface_sharing_info)(void *data,
				     struct ias_hmi *ias_hmi,
				     uint32_t id,
				     const char *title,
				     uint32_t shareable,
				     uint32_t pid,
				     const char *pname);
	/**
	 * Send weston buffer handle to client
	 *
	 * Send raw weston buffers to a client that has registered an
	 * interest in the buffers for a particular surface or output. The
	 * client will need to know the stride of each plane.
	 */
	void (*raw_buffer_handle)(void *data,
				  struct ias_hmi *ias_hmi,
				  int32_t handle,
				  uint32_t timestamp,
				  uint32_t frame_number,
				  uint32_t stride0,
				  uint32_t stride1,
				  uint32_t stride2,
				  uint32_t format,
				  uint32_t out_width,
				  uint32_t out_height,
				  uint32_t shm_surf_id,
				  uint32_t buf_id,
				  uint32_t image_id);
	/**
	 * Send weston buffer prime fd to client
	 *
	 * Send raw weston buffers to a client that has registered an
	 * interest in the buffers for a particular surface or output. The
	 * client will need to know the stride of each plane.
	 */
	void (*raw_buffer_fd)(void *data,
			      struct ias_hmi *ias_hmi,
			      int32_t prime_fd,
			      uint32_t timestamp,
			      uint32_t frame_number,
			      uint32_t stride0,
			      uint32_t stride1,
			      uint32_t stride2,
			      uint32_t format,
			      uint32_t out_width,
			      uint32_t out_height);
	/**
	 * Send capture error notification to client
	 *
	 * The client needs to be informed of any errors that may occur
	 * during creation or operation of the frame capture. We can send
	 * error codes through here to prompt shutdown of the client
	 * application, should the error be fatal.
	 */
	void (*capture_error)(void *data,
			      struct ias_hmi *ias_hmi,
			      int32_t pid,
			      int32_t error);
};

/**
 * @ingroup iface_ias_hmi
 */
static inline int
ias_hmi_add_listener(struct ias_hmi *ias_hmi,
		     const struct ias_hmi_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) ias_hmi,
				     (void (**)(void)) listener, data);
}

#define IAS_HMI_SET_CONSTANT_ALPHA 0
#define IAS_HMI_MOVE_SURFACE 1
#define IAS_HMI_RESIZE_SURFACE 2
#define IAS_HMI_ZORDER_SURFACE 3
#define IAS_HMI_SET_VISIBLE 4
#define IAS_HMI_SET_BEHAVIOR 5
#define IAS_HMI_SET_SHAREABLE 6
#define IAS_HMI_GET_SURFACE_SHARING_INFO 7
#define IAS_HMI_START_CAPTURE 8
#define IAS_HMI_STOP_CAPTURE 9
#define IAS_HMI_RELEASE_BUFFER_HANDLE 10

/**
 * @ingroup iface_ias_hmi
 */
#define IAS_HMI_SURFACE_INFO_SINCE_VERSION 1
/**
 * @ingroup iface_ias_hmi
 */
#define IAS_HMI_SURFACE_DESTROYED_SINCE_VERSION 1
/**
 * @ingroup iface_ias_hmi
 */
#define IAS_HMI_SURFACE_SHARING_INFO_SINCE_VERSION 1
/**
 * @ingroup iface_ias_hmi
 */
#define IAS_HMI_RAW_BUFFER_HANDLE_SINCE_VERSION 1
/**
 * @ingroup iface_ias_hmi
 */
#define IAS_HMI_RAW_BUFFER_FD_SINCE_VERSION 1
/**
 * @ingroup iface_ias_hmi
 */
#define IAS_HMI_CAPTURE_ERROR_SINCE_VERSION 1

/**
 * @ingroup iface_ias_hmi
 */
#define IAS_HMI_SET_CONSTANT_ALPHA_SINCE_VERSION 1
/**
 * @ingroup iface_ias_hmi
 */
#define IAS_HMI_MOVE_SURFACE_SINCE_VERSION 1
/**
 * @ingroup iface_ias_hmi
 */
#define IAS_HMI_RESIZE_SURFACE_SINCE_VERSION 1
/**
 * @ingroup iface_ias_hmi
 */
#define IAS_HMI_ZORDER_SURFACE_SINCE_VERSION 1
/**
 * @ingroup iface_ias_hmi
 */
#define IAS_HMI_SET_VISIBLE_SINCE_VERSION 1
/**
 * @ingroup iface_ias_hmi
 */
#define IAS_HMI_SET_BEHAVIOR_SINCE_VERSION 1
/**
 * @ingroup iface_ias_hmi
 */
#define IAS_HMI_SET_SHAREABLE_SINCE_VERSION 1
/**
 * @ingroup iface_ias_hmi
 */
#define IAS_HMI_GET_SURFACE_SHARING_INFO_SINCE_VERSION 1
/**
 * @ingroup iface_ias_hmi
 */
#define IAS_HMI_START_CAPTURE_SINCE_VERSION 1
/**
 * @ingroup iface_ias_hmi
 */
#define IAS_HMI_STOP_CAPTURE_SINCE_VERSION 1
/**
 * @ingroup iface_ias_hmi
 */
#define IAS_HMI_RELEASE_BUFFER_HANDLE_SINCE_VERSION 1

/** @ingroup iface_ias_hmi */
static inline void
ias_hmi_set_user_data(struct ias_hmi *ias_hmi, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) ias_hmi, user_data);
}

/** @ingroup iface_ias_hmi */
static inline void *
ias_hmi_get_user_data(struct ias_hmi *ias_hmi)
{
	return wl_proxy_get_user_data((struct wl_proxy *) ias_hmi);
}

static inline uint32_t
ias_hmi_get_version(struct ias_hmi *ias_hmi)
{
	return wl_proxy_get_version((struct wl_proxy *) ias_hmi);
}

/** @ingroup iface_ias_hmi */
static inline void
ias_hmi_destroy(struct ias_hmi *ias_hmi)
{
	wl_proxy_destroy((struct wl_proxy *) ias_hmi);
}

/**
 * @ingroup iface_ias_hmi
 *
 * Sets the constant alpha value (transparency) of a surface.  If
 * the surface is currently bound to a hardware sprite plane, this
 * will cause the sprite plane's constant alpha to be adjusted.
 * If the surface is not bound to a sprite, the shaders used to
 * draw it will be updated to reflect the appropriate transparency.
 */
static inline void
ias_hmi_set_constant_alpha(struct ias_hmi *ias_hmi, uint32_t id, uint32_t alpha)
{
	wl_proxy_marshal((struct wl_proxy *) ias_hmi,
			 IAS_HMI_SET_CONSTANT_ALPHA, id, alpha);
}

/**
 * @ingroup iface_ias_hmi
 *
 * Sets the position of the surface relative to the output. 
 *
 * This request cannot be used on background surfaces or surfaces
 * that have been made fullscreen via the set_fullscreen request.
 */
static inline void
ias_hmi_move_surface(struct ias_hmi *ias_hmi, uint32_t id, int32_t x, int32_t y)
{
	wl_proxy_marshal((struct wl_proxy *) ias_hmi,
			 IAS_HMI_MOVE_SURFACE, id, x, y);
}

/**
 * @ingroup iface_ias_hmi
 *
 * Change the dimensions of a surface.
 *
 * This request would be considered invalid in the following cases:
 * 1) Attempt to resize Background or fullscreen surfaces
 * 2) Resizing a surface to have a width or height of 0
 *
 * For all the invalid cases mentioned above, the HMI client that 
 * made this request would be notified by calling send_surface_info().
 */
static inline void
ias_hmi_resize_surface(struct ias_hmi *ias_hmi, uint32_t id, uint32_t width, uint32_t height)
{
	wl_proxy_marshal((struct wl_proxy *) ias_hmi,
			 IAS_HMI_RESIZE_SURFACE, id, width, height);
}

/**
 * @ingroup iface_ias_hmi
 *
 * Change the z-order of the surface.  This sets the surface
 * z-order to a custom value between 0 and 0xffffff. The
 * default surface z-order is 0.
 *
 * This request cannot be used on background surfaces, popup
 * surfaces, or surfaces that have been made fullscreen via
 * the set_fullscreen request.
 */
static inline void
ias_hmi_zorder_surface(struct ias_hmi *ias_hmi, uint32_t id, uint32_t zorder)
{
	wl_proxy_marshal((struct wl_proxy *) ias_hmi,
			 IAS_HMI_ZORDER_SURFACE, id, zorder);
}

/**
 * @ingroup iface_ias_hmi
 *
 * Set the surface behavior bit to make it hidden or visible.
 */
static inline void
ias_hmi_set_visible(struct ias_hmi *ias_hmi, uint32_t id, uint32_t visible)
{
	wl_proxy_marshal((struct wl_proxy *) ias_hmi,
			 IAS_HMI_SET_VISIBLE, id, visible);
}

/**
 * @ingroup iface_ias_hmi
 *
 * Set the surface custom behavior bits.
 */
static inline void
ias_hmi_set_behavior(struct ias_hmi *ias_hmi, uint32_t id, uint32_t behavior_bits)
{
	wl_proxy_marshal((struct wl_proxy *) ias_hmi,
			 IAS_HMI_SET_BEHAVIOR, id, behavior_bits);
}

/**
 * @ingroup iface_ias_hmi
 *
 * Set the surface flag to make it available for sharing or not.
 */
static inline void
ias_hmi_set_shareable(struct ias_hmi *ias_hmi, uint32_t id, uint32_t shareable)
{
	wl_proxy_marshal((struct wl_proxy *) ias_hmi,
			 IAS_HMI_SET_SHAREABLE, id, shareable);
}

/**
 * @ingroup iface_ias_hmi
 *
 * HMI client that made this request would be notified by surface_sharing_info
 * event about shareable flag for all clients surfaces
 */
static inline void
ias_hmi_get_surface_sharing_info(struct ias_hmi *ias_hmi, uint32_t id)
{
	wl_proxy_marshal((struct wl_proxy *) ias_hmi,
			 IAS_HMI_GET_SURFACE_SHARING_INFO, id);
}

/**
 * @ingroup iface_ias_hmi
 *
 * Tell frame capture to start sending frames to client.
 */
static inline void
ias_hmi_start_capture(struct ias_hmi *ias_hmi, uint32_t surfid, uint32_t output_number, int32_t profile, int32_t verbose)
{
	wl_proxy_marshal((struct wl_proxy *) ias_hmi,
			 IAS_HMI_START_CAPTURE, surfid, output_number, profile, verbose);
}

/**
 * @ingroup iface_ias_hmi
 *
 * Tell frame capture to stop sending frames to client.
 */
static inline void
ias_hmi_stop_capture(struct ias_hmi *ias_hmi, uint32_t surfid, uint32_t output_number)
{
	wl_proxy_marshal((struct wl_proxy *) ias_hmi,
			 IAS_HMI_STOP_CAPTURE, surfid, output_number);
}

/**
 * @ingroup iface_ias_hmi
 *
 * The handle was sent to the client for encoding, this is
 * a message that requests it is done with and can be
 * destroyed to free resources.
 */
static inline void
ias_hmi_release_buffer_handle(struct ias_hmi *ias_hmi, uint32_t shm_surf_id, uint32_t buf_id, uint32_t image_id, uint32_t surfid, uint32_t output_number)
{
	wl_proxy_marshal((struct wl_proxy *) ias_hmi,
			 IAS_HMI_RELEASE_BUFFER_HANDLE, shm_surf_id, buf_id, image_id, surfid, output_number);
}

#ifndef IAS_RELAY_INPUT_TOUCH_EVENT_TYPE_ENUM
#define IAS_RELAY_INPUT_TOUCH_EVENT_TYPE_ENUM
enum ias_relay_input_touch_event_type {
	/**
	 * Down event
	 */
	IAS_RELAY_INPUT_TOUCH_EVENT_TYPE_DOWN = 0,
	/**
	 * Up event
	 */
	IAS_RELAY_INPUT_TOUCH_EVENT_TYPE_UP = 1,
	/**
	 * Motion event
	 */
	IAS_RELAY_INPUT_TOUCH_EVENT_TYPE_MOTION = 2,
	/**
	 * Frame event
	 */
	IAS_RELAY_INPUT_TOUCH_EVENT_TYPE_FRAME = 3,
	/**
	 * Cancel event
	 */
	IAS_RELAY_INPUT_TOUCH_EVENT_TYPE_CANCEL = 4,
};
#endif /* IAS_RELAY_INPUT_TOUCH_EVENT_TYPE_ENUM */

#ifndef IAS_RELAY_INPUT_KEY_EVENT_TYPE_ENUM
#define IAS_RELAY_INPUT_KEY_EVENT_TYPE_ENUM
enum ias_relay_input_key_event_type {
	/**
	 * Enter key event
	 */
	IAS_RELAY_INPUT_KEY_EVENT_TYPE_ENTER = 0,
	/**
	 * Leave key event
	 */
	IAS_RELAY_INPUT_KEY_EVENT_TYPE_LEAVE = 1,
	/**
	 * Key event
	 */
	IAS_RELAY_INPUT_KEY_EVENT_TYPE_KEY = 2,
	/**
	 * Modifiers event
	 */
	IAS_RELAY_INPUT_KEY_EVENT_TYPE_MODIFIERS = 3,
};
#endif /* IAS_RELAY_INPUT_KEY_EVENT_TYPE_ENUM */

#define IAS_RELAY_INPUT_SEND_TOUCH 0
#define IAS_RELAY_INPUT_SEND_KEY 1


/**
 * @ingroup iface_ias_relay_input
 */
#define IAS_RELAY_INPUT_SEND_TOUCH_SINCE_VERSION 1
/**
 * @ingroup iface_ias_relay_input
 */
#define IAS_RELAY_INPUT_SEND_KEY_SINCE_VERSION 1

/** @ingroup iface_ias_relay_input */
static inline void
ias_relay_input_set_user_data(struct ias_relay_input *ias_relay_input, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) ias_relay_input, user_data);
}

/** @ingroup iface_ias_relay_input */
static inline void *
ias_relay_input_get_user_data(struct ias_relay_input *ias_relay_input)
{
	return wl_proxy_get_user_data((struct wl_proxy *) ias_relay_input);
}

static inline uint32_t
ias_relay_input_get_version(struct ias_relay_input *ias_relay_input)
{
	return wl_proxy_get_version((struct wl_proxy *) ias_relay_input);
}

/** @ingroup iface_ias_relay_input */
static inline void
ias_relay_input_destroy(struct ias_relay_input *ias_relay_input)
{
	wl_proxy_destroy((struct wl_proxy *) ias_relay_input);
}

/**
 * @ingroup iface_ias_relay_input
 *
 * If a user input touch event should be directed to a specific
 * application then this request is used to pass the event and
 * the ID of the application to the server.
 */
static inline void
ias_relay_input_send_touch(struct ias_relay_input *ias_relay_input, uint32_t touch_event_type, uint32_t surfid, uint32_t touch_id, uint32_t x, uint32_t y, uint32_t time)
{
	wl_proxy_marshal((struct wl_proxy *) ias_relay_input,
			 IAS_RELAY_INPUT_SEND_TOUCH, touch_event_type, surfid, touch_id, x, y, time);
}

/**
 * @ingroup iface_ias_relay_input
 *
 * If a user input key event should be directed to a specific
 * application then this request is used to pass the event and
 * the ID of the application to the server.
 */
static inline void
ias_relay_input_send_key(struct ias_relay_input *ias_relay_input, uint32_t key_event_type, uint32_t surfid, uint32_t time, uint32_t key, uint32_t state, uint32_t mods_depressed, uint32_t mods_latched, uint32_t mods_locked, uint32_t group)
{
	wl_proxy_marshal((struct wl_proxy *) ias_relay_input,
			 IAS_RELAY_INPUT_SEND_KEY, key_event_type, surfid, time, key, state, mods_depressed, mods_latched, mods_locked, group);
}

#ifdef  __cplusplus
}
#endif

#endif
